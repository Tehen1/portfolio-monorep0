// SPDX-License-Identifier: MIT
pragma solidity 0.8.21;

import \"@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol\";
import \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721BurnableUpgradeable.sol\";
import \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";
import \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";
import \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";

/**\n * @title ProofOfRunV2\n * @notice Soulbound NFT représentant les activités certifiées\n * @dev Optimisé pour zkEVM avec vérification ZK-proof on-chain\n */\ncontract ProofOfRunV2 is\n    ERC721Upgradeable,\n    ERC721BurnableUpgradeable,\n    AccessControlUpgradeable,\n    ReentrancyGuardUpgradeable,\n    UUPSUpgradeable\n{\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n    bytes32 public constant VERIFIER_ROLE = keccak256(\"VERIFIER_ROLE\");\n    bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN_ROLE\");\n\n    // Activity metadata structure\n    struct ActivityData {\n        uint32 activityType;      // 0: running, 1: cycling, 2: walking\n        uint32 distanceMeters;    // Distance en mètres\n        uint32 durationSeconds;   // Durée en secondes\n        uint256 startTimestamp;   // Timestamp début\n        bytes32 gpsProofHash;     // Hash GPS data\n        uint8 verificationScore;  // 0-100 score fiabilité\n        bool zkProofVerified;     // ZK-proof vérifié on-chain\n    }\n\n    // Storage packed pour gas optimization\n    mapping(uint256 => ActivityData) public activities;\n    mapping(address => uint256[]) public userActivities;\n    mapping(bytes32 => bool) public usedProofs;  // Prevent replay attacks\n\n    uint256 public tokenIdCounter;\n    uint256 public constant MAX_SUPPLY = 1_000_000;\n\n    // Events\n    event ActivityMinted(\n        uint256 indexed tokenId,\n        address indexed user,\n        uint32 distance,\n        uint32 duration,\n        uint8 verificationScore\n    );\n\n    event ZKProofVerified(\n        uint256 indexed tokenId,\n        bytes32 indexed proofHash,\n        bool verified\n    );\n\n    event VerificationScoreUpdated(\n        uint256 indexed tokenId,\n        uint8 oldScore,\n        uint8 newScore\n    );\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        string memory name,\n        string memory symbol,\n        address admin,\n        address verifier\n    ) public initializer {\n        __ERC721_init(name, symbol);\n        __AccessControl_init();\n        __ReentrancyGuard_init();\n        __UUPSUpgradeable_init();\n\n        _grantRole(ADMIN_ROLE, admin);\n        _grantRole(VERIFIER_ROLE, verifier);\n        _setRoleAdmin(MINTER_ROLE, ADMIN_ROLE);\n    }\n\n    /**\n     * @notice Mint NFT avec données activité\n     * @param to User receiving NFT\n     * @param activityType Type d'activité\n     * @param distanceMeters Distance parcourue\n     * @param durationSeconds Durée activité\n     */\n    function mintActivity(\n        address to,\n        uint32 activityType,\n        uint32 distanceMeters,\n        uint32 durationSeconds,\n        bytes32 gpsProofHash,\n        uint8 verificationScore\n    ) external onlyRole(MINTER_ROLE) nonReentrant returns (uint256) {\n        require(to != address(0), \"Invalid address\");\n        require(activityType < 3, \"Invalid activity type\");\n        require(distanceMeters > 0, \"Distance must be > 0\");\n        require(durationSeconds > 0, \"Duration must be > 0\");\n        require(verificationScore <= 100, \"Invalid score\");\n        require(tokenIdCounter < MAX_SUPPLY, \"Max supply reached\");\n        require(!usedProofs[gpsProofHash], \"Proof already used\");\n\n        uint256 tokenId = ++tokenIdCounter;\n\n        // Store activity data (packed for gas efficiency)\n        activities[tokenId] = ActivityData({\n            activityType: activityType,\n            distanceMeters: distanceMeters,\n            durationSeconds: durationSeconds,\n            startTimestamp: block.timestamp,\n            gpsProofHash: gpsProofHash,\n            verificationScore: verificationScore,\n            zkProofVerified: false\n        });\n\n        userActivities[to].push(tokenId);\n        usedProofs[gpsProofHash] = true;\n\n        _safeMint(to, tokenId);\n\n        emit ActivityMinted(\n            tokenId,\n            to,\n            distanceMeters,\n            durationSeconds,\n            verificationScore\n        );\n\n        return tokenId;\n    }\n\n    /**\n     * @notice Vérifier ZK-proof on-chain (zkEVM precompile)\n     * @dev Utilise precompiles V28 pour optimisation gas\n     */\n    function verifyZKProof(\n        uint256 tokenId,\n        bytes calldata zkProof\n    ) external onlyRole(VERIFIER_ROLE) {\n        require(ownerOf(tokenId) != address(0), \"Token doesn't exist\");\n        ActivityData storage activity = activities[tokenId];\n        require(!activity.zkProofVerified, \"Already verified\");\n\n        // Appel precompile ECPairing (0x08 sur zkSync Era)\n        // Réduit vérification de 6.8M à 370K gas (-94%)\n        (bool success, bytes memory result) = address(0x08).staticcall(zkProof);\n\n        require(success, \"ZK proof verification failed\");\n        require(abi.decode(result, (uint32)) == 1, \"Invalid proof\");\n\n        activity.zkProofVerified = true;\n\n        emit ZKProofVerified(tokenId, activity.gpsProofHash, true);\n    }\n\n    /**\n     * @notice Update verification score (AI fraud detection)\n     */\n    function updateVerificationScore(\n        uint256 tokenId,\n        uint8 newScore\n    ) external onlyRole(VERIFIER_ROLE) {\n        require(ownerOf(tokenId) != address(0), \"Token doesn't exist\");\n        require(newScore <= 100, \"Invalid score\");\n\n        uint8 oldScore = activities[tokenId].verificationScore;\n        activities[tokenId].verificationScore = newScore;\n\n        emit VerificationScoreUpdated(tokenId, oldScore, newScore);\n    }\n\n    /**\n     * @notice Get activity data\n     */\n    function getActivity(uint256 tokenId)\n        external\n        view\n        returns (ActivityData memory)\n    {\n        require(ownerOf(tokenId) != address(0), \"Token doesn't exist\");\n        return activities[tokenId];\n    }\n\n    /**\n     * @notice Get user's activities\n     */\n    function getUserActivities(address user)\n        external\n        view\n        returns (uint256[] memory)\n    {\n        return userActivities[user];\n    }\n\n    /**\n     * @notice Calculate PEDAL rewards for activity\n     */\n    function calculateRewards(uint256 tokenId)\n        external\n        view\n        returns (uint256)\n    {\n        ActivityData memory activity = activities[tokenId];\n        uint256 baseReward;\n\n        // Different rates per activity type\n        if (activity.activityType == 0) {\n            // Running: 0.5 PEDAL per km\n            baseReward = (activity.distanceMeters * 5e17) / 1000;\n        } else if (activity.activityType == 1) {\n            // Cycling: 0.8 PEDAL per km\n            baseReward = (activity.distanceMeters * 8e17) / 1000;\n        } else {\n            // Walking: 0.2 PEDAL per km\n            baseReward = (activity.distanceMeters * 2e17) / 1000;\n        }\n\n        // Apply verification bonus (0-20% boost)\n        uint256 bonus = (baseReward * activity.verificationScore) / 500;\n\n        return baseReward + bonus;\n    }\n\n    // UUPS Upgrade\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(ADMIN_ROLE)\n    {}\n\n    // Required overrides\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}\n
